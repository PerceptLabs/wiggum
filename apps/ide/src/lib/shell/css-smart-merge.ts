/**
 * Smart CSS Merge — intercepts writes to src/index.css when a generated theme exists.
 * Preserves the theme zone, validates WCAG contrast on color overrides,
 * accepts non-color overrides, appends custom CSS, and reports results.
 */

import { parseOklch, contrastRatio } from '../theme-generator/oklch'
import { CONTRAST_PAIRS } from '../theme-generator/dtcg'

const THEME_MARKER = '/* Generated by theme command'

export interface SmartMergeResult {
  content: string
  report: string
  colorUpdates: Record<string, { l: number; c: number; h: number }>
  fontsComment: string | null
}

/** Extract @fonts comment from CSS */
function extractFontsComment(css: string): string | null {
  const match = css.match(/\/\*\s*@fonts:\s*(.+?)\s*\*\//)
  return match ? match[0] : null
}

/** Check if a CSS value is a color (contains oklch) */
function isColorValue(value: string): boolean {
  return value.includes('oklch(')
}

/** Extract --key: value pairs from a CSS block string */
function parseVarLines(block: string): Record<string, string> {
  const vars: Record<string, string> = {}
  const re = /--([a-zA-Z0-9-]+)\s*:\s*([^;]+);/g
  let m: RegExpExecArray | null
  while ((m = re.exec(block)) !== null) {
    vars[m[1]] = m[2].trim()
  }
  return vars
}

/** Split CSS into :root block, .dark block, and everything else */
function extractBlocks(css: string): { root: string | null; dark: string | null; custom: string } {
  let root: string | null = null
  let dark: string | null = null
  const customParts: string[] = []

  // Remove @fonts comment and theme marker before block extraction
  let cleaned = css.replace(/\/\*\s*@fonts:\s*(.+?)\s*\*\/\s*\n?/, '')
  cleaned = cleaned.replace(/\/\*\s*Generated by theme command[^*]*\*\/\s*\n?/, '')

  // Simple regex-based block extraction
  const rootMatch = cleaned.match(/:root\s*\{([^}]*(?:\{[^}]*\}[^}]*)*)\}/)
  if (rootMatch) root = rootMatch[1]

  const darkMatch = cleaned.match(/\.dark\s*\{([^}]*(?:\{[^}]*\}[^}]*)*)\}/)
  if (darkMatch) dark = darkMatch[1]

  // Remove known blocks to get custom CSS
  let custom = cleaned
    .replace(/:root\s*\{[^}]*(?:\{[^}]*\}[^}]*)*\}/, '')
    .replace(/\.dark\s*\{[^}]*(?:\{[^}]*\}[^}]*)*\}/, '')
    .replace(/\*\s*\{[^}]*\}/, '')
    .replace(/body\s*\{[^}]*\}/, '')
    .trim()

  if (custom) customParts.push(custom)

  return { root, dark, custom: customParts.join('\n\n') }
}

/**
 * Given a token name, find its contrast pair. Returns [fg, bg] or null.
 */
function findContrastPair(varName: string): [string, string] | null {
  for (const [fg, bg] of CONTRAST_PAIRS) {
    if (fg === varName || bg === varName) return [fg, bg]
  }
  return null
}

/** Validate a color override against its contrast partner. Returns ratio or null if no check needed. */
function checkContrast(
  varName: string,
  value: string,
  overrides: Record<string, string>,
  existingVars: Record<string, string>,
): { ratio: number; against: string } | null {
  const pair = findContrastPair(varName)
  if (!pair) return null // No contrast pair (chart, border, ring) — accept directly

  const [fgName, bgName] = pair
  // Use overridden value if both sides are being changed, otherwise use existing
  const fgValue = fgName === varName ? value : (overrides[fgName] ?? existingVars[fgName])
  const bgValue = bgName === varName ? value : (overrides[bgName] ?? existingVars[bgName])

  if (!fgValue || !bgValue || !isColorValue(fgValue) || !isColorValue(bgValue)) return null

  try {
    const fg = parseOklch(fgValue)
    const bg = parseOklch(bgValue)
    const ratio = Math.round(contrastRatio(fg, bg) * 10) / 10
    const against = varName === fgName ? bgName : fgName
    return { ratio, against }
  } catch {
    return null // Can't parse — skip contrast check
  }
}

export function smartMergeIndexCss(
  existingContent: string,
  incomingContent: string
): SmartMergeResult {
  // No theme marker → passthrough (raw project, no generated theme to protect)
  if (!existingContent.includes(THEME_MARKER)) {
    return { content: incomingContent, report: '', colorUpdates: {}, fontsComment: null }
  }

  // Incoming starts with theme marker → full theme rewrite (from theme --apply), passthrough
  if (incomingContent.trimStart().startsWith(THEME_MARKER)) {
    return { content: incomingContent, report: '', colorUpdates: {}, fontsComment: null }
  }

  // Extract @fonts comment from incoming
  const fontsComment = extractFontsComment(incomingContent)

  // Parse incoming into blocks
  const incoming = extractBlocks(incomingContent)
  const lightOverrides = incoming.root ? parseVarLines(incoming.root) : {}
  const darkOverrides = incoming.dark ? parseVarLines(incoming.dark) : {}

  // Parse existing CSS to get current var values (for contrast checking)
  const existingBlocks = extractBlocks(existingContent)
  const existingLight = existingBlocks.root ? parseVarLines(existingBlocks.root) : {}
  const existingDark = existingBlocks.dark ? parseVarLines(existingBlocks.dark) : {}

  // Track results
  const colorUpdates: Record<string, { l: number; c: number; h: number }> = {}
  const accepted: string[] = []
  const failedOverrides: Array<{ varName: string; value: string; ratio: number; against: string }> = []

  // Process light overrides
  const appliedLight: Record<string, string> = {}
  for (const [varName, value] of Object.entries(lightOverrides)) {
    if (isColorValue(value)) {
      const result = checkContrast(varName, value, lightOverrides, existingLight)
      if (result && result.ratio < 4.5) {
        failedOverrides.push({ varName, value, ratio: result.ratio, against: result.against })
      } else {
        appliedLight[varName] = value
        accepted.push(varName)
        try {
          colorUpdates[varName] = parseOklch(value)
        } catch { /* non-standard oklch — skip token update */ }
      }
    } else {
      // Non-color override — always accept
      appliedLight[varName] = value
      accepted.push(varName)
    }
  }

  // Process dark overrides (same logic, no token sync)
  const appliedDark: Record<string, string> = {}
  for (const [varName, value] of Object.entries(darkOverrides)) {
    if (isColorValue(value)) {
      const result = checkContrast(varName, value, darkOverrides, existingDark)
      if (result && result.ratio < 4.5) {
        failedOverrides.push({ varName: 'dark:' + varName, value, ratio: result.ratio, against: result.against })
      } else {
        appliedDark[varName] = value
        accepted.push('dark:' + varName)
      }
    } else {
      appliedDark[varName] = value
      accepted.push('dark:' + varName)
    }
  }

  // Rebuild theme zone with overrides applied
  const merged = applyOverridesToThemeZone(existingContent, appliedLight, appliedDark)

  // Count vars in theme zone
  const varCount = (existingContent.match(/--[a-zA-Z0-9-]+\s*:/g) || []).length

  // Assemble final output
  // Note: merged already includes existing custom CSS (applyOverridesToThemeZone processes all lines)
  const parts: string[] = []
  if (fontsComment) parts.push(fontsComment)
  parts.push(merged)
  if (incoming.custom.trim()) parts.push(incoming.custom)

  const content = parts.join('\n\n') + '\n'

  // Build report
  const customBytes = incoming.custom.trim().length
  let report = `Wrote src/index.css — preserved theme (${varCount} vars)`

  if (accepted.length > 0 && failedOverrides.length === 0) {
    report += `, applied ${accepted.length} overrides`
  } else if (accepted.length > 0 && failedOverrides.length > 0) {
    report += `, applied ${accepted.length} overrides (skipped ${failedOverrides.length}: contrast too low)`
  } else if (failedOverrides.length > 0) {
    report += ` (skipped ${failedOverrides.length} overrides: contrast too low)`
  }

  if (customBytes > 0) {
    report += `, appended custom CSS (${customBytes} bytes)`
  }

  if (failedOverrides.length > 0) {
    report += '\n\u26a0 Skipped overrides (WCAG AA contrast < 4.5:1):'
    for (const f of failedOverrides) {
      report += `\n  --${f.varName}: ${f.value} \u2192 ratio ${f.ratio}:1 against ${f.against}. Use: theme modify --shift-hue`
    }
  }

  return { content, report, colorUpdates, fontsComment }
}

/** Apply var overrides to existing theme zone CSS (line by line replacement) */
function applyOverridesToThemeZone(
  existingCss: string,
  lightOverrides: Record<string, string>,
  darkOverrides: Record<string, string>
): string {
  const lines = existingCss.split('\n')
  const result: string[] = []
  let inDark = false

  for (const line of lines) {
    if (line.trimStart().startsWith('.dark')) inDark = true
    if (inDark && line.trim() === '}') inDark = false

    const varMatch = line.match(/^(\s*)(--([a-zA-Z0-9-]+))\s*:\s*([^;]+);/)
    if (varMatch) {
      const [, indent, fullVar, varName] = varMatch
      const overrides = inDark ? darkOverrides : lightOverrides
      if (overrides[varName] !== undefined) {
        result.push(`${indent}${fullVar}: ${overrides[varName]};`)
        continue
      }
    }

    result.push(line)
  }

  // Remove trailing empty lines (we control spacing in assembly)
  while (result.length > 0 && result[result.length - 1].trim() === '') result.pop()

  return result.join('\n')
}
